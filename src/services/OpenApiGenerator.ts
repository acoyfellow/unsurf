import { Context, Effect, Layer, Option } from "effect";
import type { CapturedEndpoint } from "../domain/Endpoint.js";

// ==================== Service Interface ====================

export interface OpenApiGeneratorService {
	/** Generate an OpenAPI 3.1 spec from captured endpoints */
	readonly generate: (
		siteUrl: string,
		endpoints: ReadonlyArray<CapturedEndpoint>,
	) => Effect.Effect<Record<string, unknown>>;
}

export class OpenApiGenerator extends Context.Tag("OpenApiGenerator")<
	OpenApiGenerator,
	OpenApiGeneratorService
>() {}

// ==================== Implementation ====================

type JsonSchema = Record<string, unknown>;
type PathItem = Record<string, unknown>;
type Operation = Record<string, unknown>;

const METHODS_WITH_BODY = new Set(["POST", "PUT", "PATCH"]);

function endpointToOperation(ep: CapturedEndpoint): Operation {
	const op: Operation = {
		operationId: `${ep.method.toLowerCase()}_${ep.pathPattern
			.replace(/[/:{}]/g, "_")
			.replace(/_+/g, "_")
			.replace(/^_|_$/g, "")}`,
		responses: {},
	};

	// Request body for POST/PUT/PATCH
	if (METHODS_WITH_BODY.has(ep.method)) {
		const reqSchema = Option.isSome(ep.requestSchema)
			? (ep.requestSchema.value as JsonSchema)
			: undefined;

		if (reqSchema) {
			op.requestBody = {
				required: true,
				content: { "application/json": { schema: reqSchema } },
			};
		}
	}

	// Response
	const resSchema = Option.isSome(ep.responseSchema)
		? (ep.responseSchema.value as JsonSchema)
		: undefined;

	op.responses = {
		"200": resSchema
			? {
					description: "Successful response",
					content: { "application/json": { schema: resSchema } },
				}
			: { description: "Successful response" },
	};

	// Extract path parameters from pattern
	const pathParams = extractPathParams(ep.pathPattern);
	if (pathParams.length > 0) {
		op.parameters = pathParams;
	}

	return op;
}

function extractPathParams(pattern: string): Record<string, unknown>[] {
	const params: Record<string, unknown>[] = [];
	const segments = pattern.split("/");

	for (const seg of segments) {
		if (seg.startsWith(":")) {
			const name = seg.slice(1);
			params.push({
				name,
				in: "path",
				required: true,
				schema: { type: "string" },
			});
		}
	}

	return params;
}

/** Convert :param to {param} for OpenAPI path format */
function toOpenApiPath(pattern: string): string {
	return pattern.replace(/:([a-zA-Z_][a-zA-Z0-9_]*)/g, "{$1}");
}

function groupByPath(endpoints: ReadonlyArray<CapturedEndpoint>): Map<string, CapturedEndpoint[]> {
	const groups = new Map<string, CapturedEndpoint[]>();
	for (const ep of endpoints) {
		const path = ep.pathPattern;
		const existing = groups.get(path) ?? [];
		existing.push(ep);
		groups.set(path, existing);
	}
	return groups;
}

function buildSpec(
	siteUrl: string,
	endpoints: ReadonlyArray<CapturedEndpoint>,
): Record<string, unknown> {
	const paths: Record<string, PathItem> = {};

	const grouped = groupByPath(endpoints);

	for (const [pattern, eps] of grouped) {
		const openApiPath = toOpenApiPath(pattern);
		const pathItem: PathItem = {};

		for (const ep of eps) {
			const method = ep.method.toLowerCase();
			pathItem[method] = endpointToOperation(ep);
		}

		paths[openApiPath] = pathItem;
	}

	let domain: string;
	try {
		domain = new URL(siteUrl).hostname;
	} catch {
		domain = siteUrl;
	}

	return {
		openapi: "3.1.0",
		info: {
			title: `API for ${domain}`,
			version: "1.0.0",
			description: `Auto-generated by unsurf from ${siteUrl}`,
		},
		servers: [{ url: siteUrl }],
		paths,
	};
}

// ==================== Service Factory ====================

export function makeOpenApiGenerator(): OpenApiGeneratorService {
	return {
		generate: (siteUrl, endpoints) => Effect.succeed(buildSpec(siteUrl, endpoints)),
	};
}

export const OpenApiGeneratorLive = Layer.succeed(OpenApiGenerator, makeOpenApiGenerator());
